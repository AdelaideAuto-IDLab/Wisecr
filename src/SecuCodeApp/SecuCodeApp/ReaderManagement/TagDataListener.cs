using System;
using System.Collections.Generic;
using System.Runtime.CompilerServices;
using System.Threading;
using System.Threading.Tasks;
using System.Threading.Tasks.Dataflow;

namespace SecuCodeApp
{
    public struct TagEvent
    {
        public byte[] Epc;

        public sbyte PeakRSSI;

        public TagState State => this.Epc[1] switch
        {
            0x00 => TagState.None,
            0x01 => TagState.SetOffset,
            0x02 => TagState.Done,
            0x03 => TagState.Authenticate,
            0x04 => TagState.PerformHash,
            0x05 => TagState.GetSessionKey,
            0x06 => TagState.StartInUserMode,
            0x07 => TagState.StartAttestation,
            0x08 => TagState.GetAttestationResponse,
            0x0B => TagState.EnableObserverMode,
            0x0C => TagState.DisableObserverMode,
            0x7F => TagState.RestartInBootMode,
            0x8F => TagState.BootLoader,
            _ => TagState.Unknown,
        };

        public ushort TagId => (ushort)((this.Epc[10] << 8) | this.Epc[11]);

        public int Voltage => (this.Epc[6] << 8) | this.Epc[7];

        public int Version => this.Epc[9];
    }

    public class TagDataListener
    {
        /// <summary>
        /// Returns an asynchronous stream over `TagEvent`s generated by `reader` with an optional timeout
        /// </summary>
        public static async IAsyncEnumerable<TagEvent> EventStream(
            ReaderManager reader,
            TimeSpan? timeout = null,
            [EnumeratorCancellation] CancellationToken enumCancellation = default
        )
        {
            CancellationTokenSource timeoutTokenSource = null;
            CancellationTokenSource combinedTokenSource = null;
            if (timeout != null)
            {
                timeoutTokenSource = new CancellationTokenSource();
                timeoutTokenSource.CancelAfter(timeout.Value);
                combinedTokenSource = CancellationTokenSource.CreateLinkedTokenSource(enumCancellation, timeoutTokenSource.Token);
            }
            var cancellationToken = combinedTokenSource?.Token ?? enumCancellation;

            var buffer = new BufferBlock<TagEvent>();
            var tagDataHandler = new TagDataListener(tagData => buffer.Post(tagData));

            try
            {
                reader.reader.OnRoAccessReportReceived += tagDataHandler.OnRoAccessReport;
                while (!cancellationToken.IsCancellationRequested)
                {
                    TagEvent tagEvent;
                    try
                    {
                        tagEvent = await buffer.ReceiveAsync(cancellationToken);
                    }
                    catch (TaskCanceledException)
                    {
                        break;
                    }
                    yield return tagEvent;
                }
            }
            finally
            {
                reader.reader.OnRoAccessReportReceived -= tagDataHandler.OnRoAccessReport;

                timeoutTokenSource?.Dispose();
                combinedTokenSource?.Dispose();
            }
        }

        private readonly Action<TagEvent> action;

        public TagDataListener(Action<TagEvent> action)
        {
            this.action = action;
        }

        public void OnRoAccessReport(Org.LLRP.LTK.LLRPV1.MSG_RO_ACCESS_REPORT message)
        {
            if (message.TagReportData == null)
            {
                return;
            }

            foreach (var tagReportData in message.TagReportData)
            {
                if (tagReportData.EPCParameter.Count != 0)
                {
                    var epc = Utils.GetEpcBytes(tagReportData.EPCParameter[0]);
                    if (epc != null && epc.Length >= 12)
                    {
                        this.action(new TagEvent
                        {
                            Epc = epc,
                            PeakRSSI = tagReportData.PeakRSSI.PeakRSSI,
                        });
                    }
                }
            }
        }
    }
}
